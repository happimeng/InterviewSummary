# 操作系统
## 线程和进程区别

* (1)	**拥有资源：进程是资源分配的基本单位**，但是线程不拥有资源，一个进程可以包括多个线程，这些线程共享进程资源
* (2)	**调度：线程是独立调度的基本单位**，同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程内的线程会引起进程切换
* (3)	**系统开销**：创建和撤销进程时，系统都要为之分配或回收资源，所付出的开销远大于创建或撤销线程时的开销。同样的在进程切换时，也会涉及当前执行进程 CPU 环境的保存以及新调度进程 CPU 环境的设置，而线程的切换只需保存和设置少量寄存器的内容，开销很小
* (4)	**通信方面**：进程间通信需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同意进程中的数据段（如全局变量）来进行通信。

[参考](https://juejin.cn/post/6844903809081163790)

## 进程通信

共7种：

  1. 管道/匿名管道(pipe)：管道是一种**半双工**的通信方式，数据只能单向流动，而且只能在**具有亲缘关系**的进程间使用。进程的亲缘关系通常是指父子进程关系。

     ![img](https://upload-images.jianshu.io/upload_images/1281379-05378521a7b41af4.png)

  2. 命名管道FIFO：有名管道也是**半双工**的通信方式，但是它**允许无亲缘关系**进程间的通信。

  3. 消息队列MessageQueue：消息队列是由**消息的链表**，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

  4. 共享内存SharedMemory：共享内存就是映射一段**能被其他进程**所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是**最快**的 IPC(InterProcess Communication,进程通信) 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两两配合使用，来实现进程间的同步和通信。

     ![img](https://upload-images.jianshu.io/upload_images/1281379-adfde0d80334c1f8.png)

  5. 信号量Semaphore：信号量是一个计数器，可以用来控制**多个进程对共享资源**的访问。它常作为一种**锁机制**，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

     ![img](https://upload-images.jianshu.io/upload_images/1281379-a1b276fae9db985d.png)

  6. 套接字Socket：套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行，即可以让通过网络连接的计算机上的进程进行通信。套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间进程进行双向通信的端点。

     ![img](https://upload-images.jianshu.io/upload_images/1281379-2db1deb0115ec4f2.png)

  7. 信号 ( sinal ) ： 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

  [参考1](https://www.jianshu.com/p/c1015f5ffa74)

  [参考2](https://blog.csdn.net/yang_teng_/article/details/53325280)



## **键盘按下一个键，之后发生了什么？**

  （不会）

  按下按键，触发中断，中断服务程序获取上下文查找中断向量表，然后执行中断处理程序，进行对应的io操作得到按键码，查找*key_layout.kl文件得到key_event然后返回。

  应用程序调用系统接口得到key down的event触发调用应用程序的处理函数(假定是渲染字符)，调用系统图形库或直接调用freetype等，执行对应字符的渲染，流程结束。

## 如果一个进程2GB， fork 之后这两个进程占用多少内存？

  还是占有2GB。

  fork（）会产生一个和父进程**完全相同**的子进程。fork()的时候，父进程的虚拟地址映射着物理内存的实际的物理地址，克隆子进程的时候，并不是在物理地址中直接再复制一份和父进程一样的物理内存块，而是子进程的虚拟地址也直接映射到同一物理内存块中，这就是**读时共享**。

  当你操作这个物理内存块时（比如修改变量的值），再复制该部分的实际物理内存到子进程中，并不是全部复制。这就是**写时复制**。所以，当你在后面的程序中操作遍历n时，就会另辟内存块给子进程，表示这两者的独立。这就是**读时共享，写时复制。**

  [参考](https://zhuanlan.zhihu.com/p/53527981)

## 死锁的产生和预防

### 1.死锁发生的情形：

（1）一个线程两次申请锁。

（2）两个线程互相申请对方的锁，但是对方都不释放锁。



### 2.死锁产生的必要条件：

（1）互斥：一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。

（2）占有且等待：当一个进程在等待分配得到其他资源时，其继续占有已分配得到的资源。

（3）非抢占：不能强行抢占进程中已占有的资源。

（4）循环等待：存在一个封闭的进程链，使得每个资源至少占有此链中下一个进程所需要的一个资源。



### 3.处理死锁的四种方法：

（1）**死锁预防：通过确保死锁的一个必要条件不会满足，保证不会发生死锁**

（2）死锁检测：允许死锁的发生，但是可以通过系统设置的检测结构及时的检测出死锁的发生，采取一些措施，将死锁清除掉

（3）死锁避免：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁

（4）死锁解除：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。

**常用方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。**

[参考](https://blog.csdn.net/hj605635529/article/details/69214903)  



## 学过操作系统，谈谈信号量，信号量如何访问，PV具体如何操作 

**信号量(semophore )** ：信号量是一个计数器，可以用一个信号量来表示系统中某种资源的数量(例如系统中只有一台打印机，可以设置一个初值为1的信号量)。它可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

**信号量的PV操作**
一对原语：**wait (S)原语和signal (S)原语**。(原语是一种特殊的程序段，其执行只能一气呵成，不能中断)，**wait原语和signal原语常被简称P、V操作**(来自荷兰语proberen和verhogen，信号量机制由荷兰科学家迪杰斯特拉提出)。分为整型信号量和记录型信号量，但是整型信号量会存在忙等的现象，目前一般**默认为记录型信号量**。

<img src="img/pv操作.png" alt="pv操作" style="zoom:150%;" />

[参考](https://www.bilibili.com/video/BV1YE411D7nH?p=21)