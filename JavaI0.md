# Java I/0
## NIO和BIO的区别 

   * IO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。

   * BIO全称是Blocking IO，是JDK1.4之前的传统IO模型，本身是同步阻塞模式。 线程发起IO请求后，一直阻塞IO，直到缓冲区数据就绪后，再进入下一步操作。

   * NIO也叫Non-Blocking IO 是同步非阻塞的IO模型。线程发起io请求后，立即返回（非阻塞io）。**同步**指的是必须等待IO缓冲区内的数据就绪，而**非阻塞**指的是，用户线程不原地等待IO缓冲区，可以先做一些其他操作，但是要**定时轮询检查IO缓冲区数据**是否就绪。IO多路复用模型中，将检查IO数据是否就绪的任务，**交给系统级别的select或epoll模型**，由系统进行监控，减轻用户线程负担。

   * BIO只能接收一个连接，无法处理大量连接。NIO单线程处理多个连接。

     [参考博客](https://juejin.cn/post/6844903985158045703)

## NIO的BIO的适用场景 

   * BIO方式适用于连接数目比较少且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，程序只管简单易理解。

   * NIO方式适用于连接数目多且比较短的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。

     [参考博客](https://my.oschina.net/u/4006148/blog/3163873)

## NIO的性能瓶颈在哪?
   网络IO往往是性能瓶颈,CPU和磁盘或许仍然会比网络速度快几个数量级。在这种情况下，你绝对不希望让异常快速的CPU等待相对缓慢的网络。
   [参考博客](http://arganzheng.life/java-nio.html)

## epoll

**epoll是linux环境下的一种IO多路复用机制。**（共有3种实现方式：select,poll,epoll）

IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。

**epoll**可以监视的文件描述符数量突破了1024的限制（十万）**，同时**不需要通过轮询遍历的方式去检查文件描述符上是否有事件发生，因为epoll_wait返回的就是有事件发生的文件描述符。本质上是事件驱动。

具体是通过**红黑树和就绪链表**实现的，红黑树存储所有的文件描述符，就绪链表存储有事件发生的文件描述符；

- **epoll_ctl**可以对文件描述符结点进行增、删、改、查，并且**告知内核注册回调函数（事件）**。
- 一旦**文件描述符上有事件发生时，那么内核将该文件描述符节点插入到就绪链表里面**
- 这时候epoll_wait将会接收到消息，并且**将数据拷贝到用户空间**。

[参考](https://blog.csdn.net/daaikuaichuan/article/details/88735256)

